import { injectable } from "inversify";
import { prisma } from "../utils/prismaClient.js";
import { AppError } from "../errors/AppError.js";
import { StatusCodes } from "http-status-codes";
import { ClientStatus } from "@prisma/client";
import ExcelJS from "exceljs";
import slugify from "slugify";
import { nanoid } from "nanoid";

@injectable()
export class ClientService {
  /**
   * CREATE CLIENT (RETAINER)
   * Generates the Admin Token (Access Key) and Obscured Slug (Public Link)
   */
  async createClient(name: string, totalHours: number, refillLink?: string) {
    // 1. Generate "Obscured Slug" (e.g. "acme-corp-x9z2k")
    const baseSlug = slugify.default(name, { lower: true, strict: true });
    const suffix = nanoid(5);
    const slug = `${baseSlug}-${suffix}`;

    // 2. Create in DB (Admin Token is auto-generated by Prisma @default(uuid))
    const client = await prisma.client.create({
      data: {
        name,
        slug,
        totalHours: totalHours, // Prisma Decimal accepts numbers
        refillLink,
        status: ClientStatus.ACTIVE,
      },
    });

    return client;
  }

  /**
   * GET CLIENT (ADMIN VIEW)
   * Returns EVERYTHING: Admin Token, Logs, Budget.
   * Used when visiting /manage/:adminToken
   */
  async getClientByAdminToken(token: string) {
    const client = await prisma.client.findUnique({
      where: { adminToken: token },
      include: {
        logs: { orderBy: { date: "desc" } },
      },
    });

    if (!client) {
      throw new AppError({
        message: "Retainer not found or invalid token",
        statusCode: StatusCodes.NOT_FOUND,
      });
    }

    return client;
  }

  /**
   * GET CLIENT (PUBLIC VIEW)
   * Returns RESTRICTED data.
   * CRITICAL: Explicitly selects fields to hide 'adminToken'.
   */
  async getClientBySlug(slug: string) {
    const client = await prisma.client.findUnique({
      where: { slug },
      select: {
        id: true,
        name: true,
        slug: true,
        totalHours: true,
        refillLink: true,
        status: true,
        createdAt: true,
        logs: {
          orderBy: { date: "desc" },
          select: {
            id: true,
            description: true,
            hours: true,
            date: true,
          },
        },
      },
    });

    if (!client) {
      throw new AppError({
        message: "Retainer dashboard not found",
        statusCode: StatusCodes.NOT_FOUND,
      });
    }

    // if (client.status === ClientStatus.ARCHIVED) {
    //   throw new AppError({
    //     message: "This project has been archived",
    //     statusCode: StatusCodes.GONE,
    //   });
    // }

    return client;
  }

  /**
   * ADD WORK LOG
   * Securely adds time to a client's history.
   */
  async addWorkLog(
    adminToken: string,
    description: string,
    hours: number,
    date: Date,
  ) {
    // 1. Verify Ownership & Check Status
    const client = await prisma.client.findUnique({
      where: { adminToken },
    });

    if (!client) {
      throw new AppError({
        message: "Invalid Access Token",
        statusCode: StatusCodes.UNAUTHORIZED,
      });
    }

    if (client.status !== ClientStatus.ACTIVE) {
      throw new AppError({
        message: `Cannot log hours. Client status is ${client.status}`,
        statusCode: StatusCodes.FORBIDDEN,
      });
    }

    // 2. Create Log
    const newLog = await prisma.workLog.create({
      data: {
        description,
        hours, // Prisma will handle Decimal conversion
        date,
        clientId: client.id,
      },
      include: {
        client: true, // Return client info so Controller can emit to the correct 'slug' room
      },
    });

    return newLog;
  }

  /**
   * DELETE LOG
   * Allows fixing mistakes.
   */
  async deleteWorkLog(adminToken: string, logId: string) {
    // 1. Verify Owner matches the log's client
    const logToCheck = await prisma.workLog.findUnique({
      where: { id: logId },
      include: { client: true },
    });

    if (!logToCheck) {
      throw new AppError({
        message: "Log entry not found",
        statusCode: StatusCodes.NOT_FOUND,
      });
    }

    if (logToCheck.client.adminToken !== adminToken) {
      throw new AppError({
        message: "Unauthorized",
        statusCode: StatusCodes.UNAUTHORIZED,
      });
    }

    // 2. Delete
    await prisma.workLog.delete({
      where: { id: logId },
    });

    return { success: true, clientSlug: logToCheck.client.slug };
  }

  async updateDetails(
    token: string,
    data: { name?: string; refillLink?: string; totalHours?: number },
  ) {
    // 1. Validate Token
    const client = await prisma.client.findUnique({
      where: { adminToken: token },
    });
    if (!client)
      throw new AppError({ message: "Invalid token", statusCode: 401 });

    // 2. Update
    return await prisma.client.update({
      where: { id: client.id },
      data: {
        ...(data.name && { name: data.name }),
        // Allow setting to null explicitly if passed
        ...(data.refillLink !== undefined && { refillLink: data.refillLink }),

        ...(data.totalHours && { totalHours: { increment: data.totalHours } }),
      },
    });
  }

  /**
   * TOGGLE STATUS (Pause/Resume)
   */
  async updateStatus(adminToken: string, status: ClientStatus) {
    return await prisma.client.update({
      where: { adminToken },
      data: { status },
    });
  }

  async deleteClient(token: string) {
    // 1. Validate Token & Get ID
    const client = await prisma.client.findUnique({
      where: { adminToken: token },
      select: { id: true },
    });

    if (!client) {
      throw new AppError({
        message: "Invalid admin token or project already deleted",
        statusCode: 404,
      });
    }

    // 2. Delete and Return Data (so we have the slug for sockets)
    return await prisma.client.delete({
      where: { id: client.id },
    });
  }

  async generateExcelReport(token: string) {
    const client = await prisma.client.findUnique({
      where: { adminToken: token },
      include: {
        logs: {
          orderBy: { date: "desc" },
        },
      },
    });

    if (!client) {
      throw new AppError({
        message: "Invalid admin token or project already deleted",
        statusCode: 404,
      });
    }

    // workbook and worksheet
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet("Work History");

    // columns
    worksheet.columns = [
      { header: "Date", key: "date", width: 15 },
      { header: "Description", key: "description", width: 40 },
      { header: "Hours Used", key: "hours", width: 15 },
    ];

    // Header Row
    const headerRow = worksheet.getRow(1);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: "center" };

    // Data Rows
    client.logs.forEach((log) => {
      worksheet.addRow({
        // Format Date to YYYY-MM-DD (ExcelJS handles date objects well, but string is safer for formatting)
        date: log.date.toISOString().split("T")[0],

        description: log.description,

        //Converting Prisma 'Decimal' to JavaScript 'Number'
        hours: log.hours.toNumber(),
      });
    });

    // Total Row
    // Calculate total hours from logs
    const totalLogged = client.logs.reduce(
      (acc, log) => acc + log.hours.toNumber(),
      0,
    );

    worksheet.addRow({}); // Empty row
    const totalRow = worksheet.addRow({
      description: "TOTAL LOGGED HOURS",
      hours: totalLogged,
    });
    totalRow.font = { bold: true };

    // Return the workbook and a clean filename
    const safeName = client.name.replace(/[^a-z0-9]/gi, "_").toLowerCase();

    return {
      workbook,
      fileName: `${safeName}_retainer_report.xlsx`,
    };
  }
}
